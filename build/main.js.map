{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/*\n * Created with @iobroker/create-adapter v2.6.2\n */\n\n// The adapter-core module gives you access to the core ioBroker functions\n// you need to create an adapter\nimport * as utils from '@iobroker/adapter-core';\nimport { parseStringPromise } from 'xml2js';\nimport packageJson from '../package.json';\nimport { getEnumKeys } from './lib/util.js';\n\n// Load your modules here, e.g.:\nimport DigestFetch from 'digest-fetch';\n\n// import * as fs from \"fs\";\nconst adapterName = packageJson.name.split('.').pop();\nconst getOptions = {\n\tmethod: 'get',\n\theaders: {\n\t\tConnection: 'Keep-Alive',\n\t\tAccept: 'text/xml',\n\t\tPragma: 'no-cache',\n\t\t'Cache-Control': 'no-cache',\n\t\t'Content-Type': 'text/xml; charset=utf-8',\n\t},\n};\n\n// /home/parallels/ioBroker.ochsner-roomterminal/node_modules/@types/iobroker/index.d.ts\nclass OchsnerRoomterminal extends utils.Adapter {\n\tprivate deviceInfoUrl = '';\n\tprivate getUrl = '';\n\tprivate client: any | undefined = undefined;\n\tprivate oidNamesDict: { [id: string]: string } | undefined = undefined;\n\tprivate oidEnumsDict: { [id: string]: string[] } | undefined = undefined;\n\tprivate oidUpdate: { [id: string]: string } = {};\n\tprivate oidGroups: Record<string, number[]> = {};\n\tprivate groupOidString: Record<string, string> = {};\n\n\tpublic constructor(options: Partial<utils.AdapterOptions> = {}) {\n\t\tsuper({\n\t\t\t...options,\n\t\t\tname: adapterName!,\n\t\t});\n\t\t// this.log.info(`Adapter Name: ${this.name}`);\n\t\t// this.log.info(`Adapter Instance: ${this.instance}`);\n\t\t// this.log.info(`Adapter Namespace: ${this.namespace}`);\n\t\tthis.on('ready', this.onReady.bind(this));\n\t\tthis.on('stateChange', this.onStateChange.bind(this));\n\t\t// this.on('objectChange', this.onObjectChange.bind(this));\n\t\tthis.on('message', this.onMessage.bind(this));\n\t\tthis.on('unload', this.onUnload.bind(this));\n\t}\n\n\t/**\n\t * Is called when databases are connected and adapter received configuration.\n\t */\n\tprivate async onReady(): Promise<void> {\n\t\t// Initialize your adapter here\n\t\tthis.subscribeStates('OID.*');\n\t\tthis.log.info(`Adapter Name: ${this.name} is ready !!!!!!`);\n\t\tthis.main();\n\t}\n\n\t/**\n\t * Is called when adapter shuts down - callback has to be called under any circumstances!\n\t */\n\tprivate onUnload(callback: () => void): void {\n\t\ttry {\n\t\t\t// Here you must clear all timeouts or intervals that may still be active\n\t\t\t// clearTimeout(timeout1);\n\t\t\t// clearTimeout(timeout2);\n\t\t\t// ...\n\t\t\t// clearInterval(interval1);\n\n\t\t\tcallback();\n\t\t} catch (e) {\n\t\t\tcallback();\n\t\t}\n\t}\n\n\t// If you need to react to object changes, uncomment the following block and the corresponding line in the constructor.\n\t// You also need to subscribe to the objects with `this.subscribeObjects`, similar to `this.subscribeStates`.\n\t// /**\n\t//  * Is called if a subscribed object changes\n\t//  */\n\t// private onObjectChange(id: string, obj: ioBroker.Object | null | undefined): void {\n\t// \tif (obj) {\n\t// \t\t// The object was changed\n\t// \t\tthis.log.info(`object ${id} changed: ${JSON.stringify(obj)}`);\n\t// \t} else { 17058\n\t// \t\t// The object was deleted\n\t// \t\tthis.log.info(`object ${id} deleted`);\n\t// \t}\n\t// }\n\n\t/**\n\t * Is called if a subscribed state changes\n\t */\n\tprivate async onStateChange(id: string, state: ioBroker.State | null | undefined): Promise<void> {\n\t\tconst oids = this.config.OIDs;\n\t\tif (state) {\n\t\t\t// The state was changed\n\t\t\tif (!state.ack) {\n\t\t\t\t// only write to device value if state is not acknowledged\n\t\t\t\tthis.log.debug(`state ${id} changed: ${state.val} (ack = ${state.ack})`);\n\t\t\t\tconst index = oids.findIndex((elem) => id.endsWith(elem.oid));\n\t\t\t\tif (index == -1) {\n\t\t\t\t\tthis.log.error(`state ${id} not found in OID list`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// this.log.debug(`adapter name: ${this.name}, namespace: ${this.namespace}`);\n\t\t\t\tthis.log.debug(`From: system.adapter.${this.name}`);\n\t\t\t\t// we are only interested in state changes, which are not from reading our OIDs\n\t\t\t\tif (!state.from.startsWith(`system.adapter.${this.name}`)) {\n\t\t\t\t\tawait this.oidWrite(index, state.val);\n\t\t\t\t\tawait this.delay(1500);\n\t\t\t\t\tawait this.oidRead(this.config.OIDs[index].oid, [index]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// The state was deleted\n\t\t\tthis.log.info(`state ${id} deleted`);\n\t\t}\n\t}\n\n\t// If you need to accept messages in your adapter, uncomment the following block and the corresponding line in the constructor.\n\t// /**\n\t//  * Some message was sent to this instance over message box. Used by email, pushover, text2speech, ...\n\t//  * Using this method requires \"common.messagebox\" property to be set to true in io-package.json\n\t//  */\n\tprivate async onMessage(obj: ioBroker.Message): Promise<void> {\n\t\tthis.log.debug('message received' + JSON.stringify(obj, null, 2));\n\t\tlet resultMsg: any = { error: 'internal error' };\n\t\t// let resultMsg = { error: false, result: 'success' };\n\t\tif (typeof obj === 'object' && obj.message) {\n\t\t\tif (obj.command === 'readGroup') {\n\t\t\t\t// read group with string 'obj.command'\n\t\t\t\tconst groupIndex = Object.keys(this.oidGroups).indexOf(String(obj.message));\n\t\t\t\tthis.log.debug(`read group ${obj.message} (groupIndex: ${groupIndex})`);\n\n\t\t\t\tif (groupIndex !== -1) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst group = String(obj.message);\n\t\t\t\t\t\t// await this.oidReadGroupOld(String(obj.message));\n\t\t\t\t\t\tawait this.oidRead(this.groupOidString[group], this.oidGroups[group]);\n\t\t\t\t\t\tresultMsg = 'success';\n\t\t\t\t\t} catch (error: any) {\n\t\t\t\t\t\tresultMsg = { error: error.message ?? 'unknown error' };\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.log.info(`group \"${obj.message}\" does not exist`);\n\t\t\t\t\tresultMsg = { error: `group ${obj.message} does not exist` };\n\t\t\t\t}\n\t\t\t} else resultMsg = { error: 'message command not supported' };\n\t\t}\n\t\t// Send response in callback if required\n\t\t// if (obj.callback) this.sendTo(obj.from, obj.command, 'Message received', obj.callback);\n\t\tif (obj.callback) {\n\t\t\tthis.sendTo(obj.from, obj.command, resultMsg, obj.callback);\n\t\t}\n\t}\n\n\t/**\n\t * Private functions\n\t */\n\n\t/**\n\t * ----------------------------\n\t *  Inititialize the adapter\n\t * ----------------------------\n\t */\n\tprivate async main(): Promise<void> {\n\t\t// Reset the connection indicator during startup\n\t\tthis.setState('info.connection', false, true);\n\n\t\t// Initialize private instance variables\n\t\tthis.deviceInfoUrl = `http://${this.config.serverIP}/api/1.0/info/deviceinfo`;\n\t\tthis.getUrl = `http://${this.config.serverIP}/ws`;\n\t\tthis.client = new DigestFetch(this.config.username, this.config.password);\n\n\t\t// Attention !!!\n\t\t// this.log.info(`Config: ${JSON.stringify(this.config, null, 2)}`);\n\n\t\t// The adapters config (in the instance object everything under the attribute \"native\") is accessible via\n\t\t// this.config:\n\t\tif (!this.config.serverIP) {\n\t\t\tthis.log.error('Server IP address configuration must not be emtpy');\n\t\t\treturn;\n\t\t}\n\n\t\tthis.log.info('Config username: ' + this.config.username);\n\t\t// this.log.info('Config password: ' + this.config.password);\n\t\tthis.log.info('Config serverIP: ' + this.config.serverIP);\n\t\tthis.log.info('Config pollInterval: ' + this.config.pollInterval);\n\n\t\t// check if connection to server is available with given credentials\n\t\tconst connected = await this.checkForConnection();\n\t\tif (!connected) {\n\t\t\treturn;\n\t\t}\n\t\tthis.setState('info.connection', true, true);\n\n\t\t/**\n\t\t * Prepare Group Handling\n\t\t * ----------------------\n\t\t * this.oidGroups = {\"group01\": [OIDsIndex01, OIDsIndex02, ....],\"group02\": [OIDsIndex01, OIDsIndex02, ....], .... }\n\t\t * this.groupOIDString = {\"group01\": \"oid1;oid3\", \"group02\": \"oid2;oid4\"}\n\t\t */\n\t\tif (this.config.OIDs?.length) {\n\t\t\tthis.config.OIDs.forEach((value, key) => {\n\t\t\t\tconst group = this.config.OIDs[key].group;\n\t\t\t\tconst enabled = this.config.OIDs[key].enabled;\n\t\t\t\tconst oid = this.config.OIDs[key].oid;\n\t\t\t\tthis.log.debug(`Key: ${key} Object: ${JSON.stringify(this.config.OIDs[key])}`);\n\t\t\t\tif (enabled) {\n\t\t\t\t\tif (this.oidGroups[group] == undefined) this.oidGroups[group] = [key];\n\t\t\t\t\telse this.oidGroups[group].push(key);\n\t\t\t\t\tif (this.groupOidString[group] == undefined) this.groupOidString[group] = oid;\n\t\t\t\t\telse this.groupOidString[group] = this.groupOidString[group] + ';' + oid;\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.log.debug(`Groups: ${JSON.stringify(this.oidGroups)}`);\n\t\t\tthis.log.debug(`Group OIDs: ${JSON.stringify(this.groupOidString)}`);\n\n\t\t\t// load the oidNames and oiEnums dictionary\n\t\t\t// TODO: read both dictionary also, when device version changed\n\t\t\tthis.oidNamesDict = await this.oidGetNames();\n\t\t\tthis.oidEnumsDict = await this.oidGetEnums();\n\t\t}\n\n\t\t// Start polling the OID's when there is at least one OID group <= 10\n\t\tif (Object.keys(this.oidGroups).findIndex((groupName) => +groupName < 10) == -1)\n\t\t\tthis.log.info('No OIDs to poll in instance configuration');\n\t\telse this.poll();\n\t}\n\n\t/**\n\t * Main polling routine - fetching next Group in list\n\t *\n\t * @description Started once during startup, restarts itself when finished\n\t * \t\t\t\t(only called when there is at least one oid)\n\t */\n\tprivate async poll(groupIndex = 0): Promise<void> {\n\t\tconst keys = Object.keys(this.oidGroups);\n\t\t// this.log.debug(`poll with groupIndex: ${groupIndex}; keys length: ${keys.length}`);\n\n\t\t// TODO: avoid delay when OID is disabled\n\t\ttry {\n\t\t\t// read the next OID group from roomterminal\n\t\t\tif (groupIndex >= keys.length) {\n\t\t\t\t// we read the last group\n\t\t\t\tawait this.updateNativeOIDs(Object.keys(this.oidUpdate));\n\t\t\t\tthis.poll(0); // start from the beginning, without delay\n\t\t\t} else if (+keys[groupIndex] > 9) {\n\t\t\t\t// groupNames from 10 onwards are reserved for messages\n\t\t\t\tthis.log.debug(\n\t\t\t\t\t`skip group ${keys[groupIndex]}, this number is reserved for readGroup messages, only!!`,\n\t\t\t\t);\n\t\t\t\tthis.poll(++groupIndex);\n\t\t\t} else {\n\t\t\t\tconst groupKey = keys[groupIndex];\n\t\t\t\tthis.log.debug(`Read Group ${groupKey}`);\n\t\t\t\t// await this.oidReadGroupOld(groupKey);\n\t\t\t\tawait this.oidRead(this.groupOidString[groupKey], this.oidGroups[groupKey]);\n\t\t\t\tawait this.delay(this.config.pollInterval * 1000);\n\t\t\t\tthis.poll(++groupIndex);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.log.error(`Error: ${JSON.stringify(error)}`);\n\t\t\tawait this.delay(this.config.pollInterval * 1000);\n\t\t\tthis.poll(0);\n\t\t}\n\t}\n\n\t/**\n\t * Check for empty OID names in config, add default names\n\t * and update common.native.OIDs in instance object (which restarts the adapter)\n\t * @param keys to update\n\t */\n\tprivate async updateNativeOIDs(keys: string[]): Promise<void> {\n\t\tthis.log.debug(`UpdateNativeOIDs: ${JSON.stringify(keys)}`);\n\t\tif (!keys.length) return; // there is nothing to update\n\t\ttry {\n\t\t\tconst instanceObj = await this.getForeignObjectAsync(`system.adapter.${this.namespace}`);\n\t\t\tif (instanceObj) {\n\t\t\t\t// this.log.debug(`Old native objects: ${JSON.stringify(instanceObj.native, null, 2)}`);\n\t\t\t\tkeys.forEach((key) => {\n\t\t\t\t\tconst index = instanceObj.native.OIDs.findIndex((oid: ioBroker.OID) => key === oid.oid);\n\t\t\t\t\tif (index !== -1) instanceObj.native.OIDs[index].name = this.oidUpdate[key] ?? key;\n\t\t\t\t});\n\t\t\t\t// this.log.debug(`New native objects: ${JSON.stringify(instanceObj.native, null, 2)}`);\n\t\t\t\tawait this.setForeignObjectAsync(`system.adapter.${this.namespace}`, instanceObj);\n\t\t\t\tthis.oidUpdate = {};\n\t\t\t\t// this.log.debug(`Instance object id: ${JSON.stringify(res, null, 2)}`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.log.debug(`getObject error: ${JSON.stringify(error, null, 2)}`);\n\t\t}\n\t}\n\n\t// TODO: pass only index array, and extract OID string from there\n\t/**\n\t * Read OID group from roomterminal, given by group oids and group indices\n\t *\n\t * @param oids OID string to read e.g. \"/1/2/3/5/8;/1/2/3/5/;/1/2/3/5/10\"\n\t * @param indices OID config indices [5,7,9] (must correspond to oids)\n\t */\n\tprivate async oidRead(oids: string, oidIndices: number[]): Promise<void> {\n\t\tthis.log.debug(`Read OIDs ${oids} (Config indices: [ ${JSON.stringify(oidIndices)} ])`);\n\n\t\t// TODO: wrong OID error handling\n\n\t\tconst body = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t\t<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" \n\t\txmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\" \n\t\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n\t\txmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" \n\t\txmlns:ns=\"http://ws01.lom.ch/soap/\">\n\t\t <SOAP-ENV:Body>\n\t\t   <ns:getDpRequest>\n\t\t\t<ref>\n\t\t\t <oid>${oids}</oid>\n\t\t\t <prop/>\n\t\t\t</ref>\n\t\t\t<startIndex>0</startIndex>\n\t\t\t<count>-1</count>\n\t\t   </ns:getDpRequest>\n\t\t </SOAP-ENV:Body>\n\t\t</SOAP-ENV:Envelope>`;\n\n\t\tconst options = {\n\t\t\tmethod: 'post',\n\t\t\tbody: body,\n\t\t\theaders: {\n\t\t\t\tConnection: 'Keep-Alive',\n\t\t\t\tAccept: 'text/xml',\n\t\t\t\tPragma: 'no-cache',\n\t\t\t\tSOAPAction: 'http://ws01.lom.ch/soap/getDP',\n\t\t\t\t'Cache-Control': 'no-cache',\n\t\t\t\t'Content-Type': 'text/xml; charset=utf-8',\n\t\t\t\t'Content-length': body.length,\n\t\t\t},\n\t\t};\n\t\ttry {\n\t\t\tconst response = await this.client.fetch(this.getUrl, options);\n\t\t\tif (response.ok == true) {\n\t\t\t\t// Reading was succcesfull\n\t\t\t\tthis.setState('info.connection', true, true);\n\n\t\t\t\tconst data = await response.text();\n\t\t\t\tthis.log.debug(`OID Raw Data: ${data}`);\n\t\t\t\tconst jsonResult = await parseStringPromise(data);\n\t\t\t\tconst dpCfg: any[] = jsonResult['SOAP-ENV:Envelope']['SOAP-ENV:Body'][0]['ns:getDpResponse'][0].dpCfg;\n\t\t\t\t// this.log.debug(`DP JSON Length: ${dpCfg.length} / oid array length: ${oidArray.length}`);\n\t\t\t\t// this.log.debug(`Data: ${JSON.stringify(dpCfg)}`);\n\n\t\t\t\t// loop through dpCfg[]\n\t\t\t\tdpCfg.forEach(async (dp, key) => {\n\t\t\t\t\tconst configOidIndex = oidIndices[key];\n\t\t\t\t\tconst oid = this.config.OIDs[configOidIndex].oid;\n\t\t\t\t\tconst states: { [key: string]: string } = {};\n\n\t\t\t\t\t// this.log.debug(`[Key: ${key}][config OID index: ${configOidIndex}] DP: ${JSON.stringify(dp)}`);\n\n\t\t\t\t\tconst name: string = dp.name[0];\n\t\t\t\t\tconst prop: string = dp.prop[0];\n\t\t\t\t\tconst desc: string = dp.desc[0];\n\t\t\t\t\tconst value: string = dp.value[0];\n\t\t\t\t\tconst unit: string = dp.unit[0];\n\t\t\t\t\tconst step: string = dp.step[0];\n\t\t\t\t\tconst min: string = dp.minValue[0];\n\t\t\t\t\tconst max: string = dp.maxValue[0];\n\n\t\t\t\t\t// this.log.debug(`desc: ${desc}, prop: ${prop}`);\n\n\t\t\t\t\tif (this.oidEnumsDict![name]) {\n\t\t\t\t\t\t// this.log.debug(`Enums ${JSON.stringify(this.oidEnumsDict![name])}`);\n\t\t\t\t\t\tif (desc === 'Enum Var') {\n\t\t\t\t\t\t\tconst enums = getEnumKeys(prop);\n\t\t\t\t\t\t\tif (enums) {\n\t\t\t\t\t\t\t\tenums.forEach(\n\t\t\t\t\t\t\t\t\t(val) => (states[val] = this.oidEnumsDict![name][Number(val)] ?? 'undefined'),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.oidEnumsDict![name].forEach((val, key) => (states[key] = val ?? 'undefined'));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// else this.log.debug('No enums for ' + name);\n\n\t\t\t\t\t// this.log.debug(`OID states: ${JSON.stringify(states)}`);\n\t\t\t\t\t// this.log.debug(`configOidIndex: ${configOidIndex}`);\n\t\t\t\t\t// this.log.debug(`name: ${this.config.OIDs[configOidIndex].name}`);\n\t\t\t\t\t// this.log.debug(`prop: ${prop}`);\n\t\t\t\t\t// this.log.debug(`unit: ${unit}`);\n\t\t\t\t\tthis.log.debug(`Update object: ${oid} - \"${name}\" with value: ${value} `);\n\n\t\t\t\t\tconst common: ioBroker.StateCommon = {\n\t\t\t\t\t\tname: this.config.OIDs[configOidIndex].name.length\n\t\t\t\t\t\t\t? this.config.OIDs[configOidIndex].name\n\t\t\t\t\t\t\t: this.oidNamesDict![name],\n\t\t\t\t\t\ttype: 'number',\n\t\t\t\t\t\trole: 'value',\n\t\t\t\t\t\tread: prop[1] === 'r' ? true : false,\n\t\t\t\t\t\twrite: prop[2] === 'w' ? true : false,\n\t\t\t\t\t\tunit: unit.length === 0 ? undefined : unit,\n\t\t\t\t\t\tmin: prop[2] === 'w' ? (min.length === 0 ? undefined : Number(min)) : undefined,\n\t\t\t\t\t\tmax: prop[2] === 'w' ? (max.length === 0 ? undefined : Number(max)) : undefined,\n\t\t\t\t\t\tstep: prop[2] === 'w' ? (step.length === 0 ? undefined : Number(step)) : undefined,\n\t\t\t\t\t\t//TODO: add states based on XML\n\t\t\t\t\t\tstates: Object.keys(states).length == 0 ? undefined : states,\n\t\t\t\t\t\t// \t// states: { '0': 'OFF', '1': 'ON', '-3': 'whatever' },\n\t\t\t\t\t};\n\t\t\t\t\t// this.log.debug(`common: ${JSON.stringify(common)}`);\n\n\t\t\t\t\tif (this.config.OIDs[configOidIndex].name.length === 0)\n\t\t\t\t\t\tthis.oidUpdate[oid] = this.oidNamesDict![name] ?? name;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (value.length > 0) {\n\t\t\t\t\t\t\tawait this.setObjectNotExistsAsync('OID.' + oid, {\n\t\t\t\t\t\t\t\ttype: 'state',\n\t\t\t\t\t\t\t\tcommon,\n\t\t\t\t\t\t\t\tnative: {},\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tthis.setState('OID.' + oid, { val: Number(value), ack: true });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this.config.OIDs[configOidIndex].isStatus) {\n\t\t\t\t\t\t\t// this.log.debug(`oidRead: for ${name}`);\n\t\t\t\t\t\t\t// this.log.debug(`Enums ${JSON.stringify(this.oidEnumsDict![name])}`);\n\t\t\t\t\t\t\tif (this.oidEnumsDict![name]) {\n\t\t\t\t\t\t\t\tconst status = this.oidEnumsDict![name][Number(value)];\n\t\t\t\t\t\t\t\tif (status) {\n\t\t\t\t\t\t\t\t\tawait this.setObjectNotExistsAsync('Status.' + oid, {\n\t\t\t\t\t\t\t\t\t\ttype: 'state',\n\t\t\t\t\t\t\t\t\t\tcommon: {\n\t\t\t\t\t\t\t\t\t\t\tname: 'Status.' + this.config.OIDs[configOidIndex].name,\n\t\t\t\t\t\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\t\t\t\t\t\trole: 'value',\n\t\t\t\t\t\t\t\t\t\t\tread: true,\n\t\t\t\t\t\t\t\t\t\t\twrite: false,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnative: {},\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tthis.setState('Status.' + oid, { val: status, ack: true });\n\t\t\t\t\t\t\t\t\tthis.log.debug(`Update status object: ${oid} with value: ${status}`);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.log.info(`No status text found for ${oid} (${name})`);\n\t\t\t\t\t\t\t\tthis.log.info(`Please check isStatus configuration for ${oid}`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error: any) {\n\t\t\t\t\t\tthis.log.error('Error message: ' + error?.message);\n\t\t\t\t\t\tthis.log.error(`State update for ${oids} failed`);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.log.error(`reading ${oids} failed! Message: ${JSON.stringify(response.statusText)}`);\n\t\t\t\tthrow new Error(`reading ${oids} failed! Message: ${JSON.stringify(response.statusText)}`);\n\t\t\t}\n\t\t} catch (_error: any) {\n\t\t\tthis.log.error('OID read or parse error: ' + oids);\n\t\t\tthis.setState('info.connection', false, true);\n\t\t\tthrow new Error(_error.message ?? 'OID read or parse error');\n\t\t}\n\t}\n\n\t/**\n\t * Read OID group from roomterminal, given by group name\n\t *\n\t * @param groupKey Name of the OID group to read\n\t */\n\t// private async oidReadGroupOld(groupKey: string): Promise<void> {\n\t// \tthis.log.debug(`Read Group ${groupKey}`);\n\t// \tconst oids = this.groupOidString[groupKey];\n\t// \tconst group = this.oidGroups[groupKey];\n\n\t// \tthis.log.debug(`OID Config Indices: [ ${JSON.stringify(group)} ]`);\n\t// \tthis.log.debug(`Read OIDs ${oids} ]`);\n\n\t// \t// TODO: wrong UID error handling\n\n\t// \tconst body = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t// \t<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\"\n\t// \txmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\"\n\t// \txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t// \txmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\n\t// \txmlns:ns=\"http://ws01.lom.ch/soap/\">\n\t// \t <SOAP-ENV:Body>\n\t// \t   <ns:getDpRequest>\n\t// \t\t<ref>\n\t// \t\t <oid>${oids}</oid>\n\t// \t\t <prop/>\n\t// \t\t</ref>\n\t// \t\t<startIndex>0</startIndex>\n\t// \t\t<count>-1</count>\n\t// \t   </ns:getDpRequest>\n\t// \t </SOAP-ENV:Body>\n\t// \t</SOAP-ENV:Envelope>`;\n\n\t// \tconst options = {\n\t// \t\tmethod: 'post',\n\t// \t\tbody: body,\n\t// \t\theaders: {\n\t// \t\t\tConnection: 'Keep-Alive',\n\t// \t\t\tAccept: 'text/xml',\n\t// \t\t\tPragma: 'no-cache',\n\t// \t\t\tSOAPAction: 'http://ws01.lom.ch/soap/getDP',\n\t// \t\t\t'Cache-Control': 'no-cache',\n\t// \t\t\t'Content-Type': 'text/xml; charset=utf-8',\n\t// \t\t\t'Content-length': body.length,\n\t// \t\t},\n\t// \t};\n\t// \ttry {\n\t// \t\tconst response = await this.client.fetch(this.getUrl, options);\n\t// \t\tif (response.ok == true) {\n\t// \t\t\t// Reading was succcesfull\n\t// \t\t\tthis.setState('info.connection', true, true);\n\n\t// \t\t\tconst data = await response.text();\n\t// \t\t\tthis.log.debug(`OID Raw Data: ${data}`);\n\t// \t\t\tconst jsonResult = await parseStringPromise(data);\n\t// \t\t\tconst dpCfg: any[] = jsonResult['SOAP-ENV:Envelope']['SOAP-ENV:Body'][0]['ns:getDpResponse'][0].dpCfg;\n\t// \t\t\t// this.log.debug(`DP JSON Length: ${dpCfg.length} / oid array length: ${oidArray.length}`);\n\t// \t\t\t// this.log.debug(`Data: ${JSON.stringify(dpCfg)}`);\n\n\t// \t\t\t// loop through dpCfg[]\n\t// \t\t\tdpCfg.forEach(async (dp, key) => {\n\t// \t\t\t\tconst configOidIndex = group[key];\n\t// \t\t\t\tconst oid = this.config.OIDs[configOidIndex].oid;\n\t// \t\t\t\tconst states: { [key: string]: string } = {};\n\n\t// \t\t\t\t// this.log.debug(`[Key: ${key}][config OID index: ${configOidIndex}] DP: ${JSON.stringify(dp)}`);\n\n\t// \t\t\t\tconst name: string = dp.name[0];\n\t// \t\t\t\tconst prop: string = dp.prop[0];\n\t// \t\t\t\tconst desc: string = dp.desc[0];\n\t// \t\t\t\tconst value: string = dp.value[0];\n\t// \t\t\t\tconst unit: string = dp.unit[0];\n\t// \t\t\t\tconst step: string = dp.step[0];\n\t// \t\t\t\tconst min: string = dp.minValue[0];\n\t// \t\t\t\tconst max: string = dp.maxValue[0];\n\n\t// \t\t\t\t// this.log.debug(`desc: ${desc}, prop: ${prop}`);\n\n\t// \t\t\t\tif (this.oidEnumsDict![name]) {\n\t// \t\t\t\t\t// this.log.debug(`Enums ${JSON.stringify(this.oidEnumsDict![name])}`);\n\t// \t\t\t\t\tif (desc === 'Enum Var') {\n\t// \t\t\t\t\t\tconst enums = getEnumKeys(prop);\n\t// \t\t\t\t\t\tif (enums) {\n\t// \t\t\t\t\t\t\tenums.forEach(\n\t// \t\t\t\t\t\t\t\t(val) => (states[val] = this.oidEnumsDict![name][Number(val)] ?? 'undefined'),\n\t// \t\t\t\t\t\t\t);\n\t// \t\t\t\t\t\t}\n\t// \t\t\t\t\t} else {\n\t// \t\t\t\t\t\tthis.oidEnumsDict![name].forEach((val, key) => (states[key] = val ?? 'undefined'));\n\t// \t\t\t\t\t}\n\t// \t\t\t\t}\n\t// \t\t\t\t// else this.log.debug('No enums for ' + name);\n\n\t// \t\t\t\t// this.log.debug(`OID states: ${JSON.stringify(states)}`);\n\t// \t\t\t\t// this.log.debug(`configOidIndex: ${configOidIndex}`);\n\t// \t\t\t\t// this.log.debug(`name: ${this.config.OIDs[configOidIndex].name}`);\n\t// \t\t\t\t// this.log.debug(`prop: ${prop}`);\n\t// \t\t\t\t// this.log.debug(`unit: ${unit}`);\n\t// \t\t\t\tthis.log.debug(`Update object: ${oid} - \"${name}\" with value: ${value} `);\n\n\t// \t\t\t\tconst common: ioBroker.StateCommon = {\n\t// \t\t\t\t\tname: this.config.OIDs[configOidIndex].name.length\n\t// \t\t\t\t\t\t? this.config.OIDs[configOidIndex].name\n\t// \t\t\t\t\t\t: this.oidNamesDict![name],\n\t// \t\t\t\t\ttype: 'number',\n\t// \t\t\t\t\trole: 'value',\n\t// \t\t\t\t\tread: prop[1] === 'r' ? true : false,\n\t// \t\t\t\t\twrite: prop[2] === 'w' ? true : false,\n\t// \t\t\t\t\tunit: unit.length === 0 ? undefined : unit,\n\t// \t\t\t\t\tmin: prop[2] === 'w' ? (min.length === 0 ? undefined : Number(min)) : undefined,\n\t// \t\t\t\t\tmax: prop[2] === 'w' ? (max.length === 0 ? undefined : Number(max)) : undefined,\n\t// \t\t\t\t\tstep: prop[2] === 'w' ? (step.length === 0 ? undefined : Number(step)) : undefined,\n\t// \t\t\t\t\t//TODO: add states based on XML\n\t// \t\t\t\t\tstates: Object.keys(states).length == 0 ? undefined : states,\n\t// \t\t\t\t\t// \t// states: { '0': 'OFF', '1': 'ON', '-3': 'whatever' },\n\t// \t\t\t\t};\n\t// \t\t\t\t// this.log.debug(`common: ${JSON.stringify(common)}`);\n\n\t// \t\t\t\tif (this.config.OIDs[configOidIndex].name.length === 0)\n\t// \t\t\t\t\tthis.oidUpdate[oid] = this.oidNamesDict![name] ?? name;\n\t// \t\t\t\ttry {\n\t// \t\t\t\t\tif (value.length > 0) {\n\t// \t\t\t\t\t\tawait this.setObjectNotExistsAsync('OID.' + oid, {\n\t// \t\t\t\t\t\t\ttype: 'state',\n\t// \t\t\t\t\t\t\tcommon,\n\t// \t\t\t\t\t\t\tnative: {},\n\t// \t\t\t\t\t\t});\n\n\t// \t\t\t\t\t\tthis.setState('OID.' + oid, { val: Number(value), ack: true });\n\t// \t\t\t\t\t}\n\t// \t\t\t\t\tif (this.config.OIDs[configOidIndex].isStatus) {\n\t// \t\t\t\t\t\t// this.log.debug(`oidReadGroup: for ${name}`);\n\t// \t\t\t\t\t\t// this.log.debug(`Enums ${JSON.stringify(this.oidEnumsDict![name])}`);\n\t// \t\t\t\t\t\tif (this.oidEnumsDict![name]) {\n\t// \t\t\t\t\t\t\tconst status = this.oidEnumsDict![name][Number(value)];\n\t// \t\t\t\t\t\t\tif (status) {\n\t// \t\t\t\t\t\t\t\tawait this.setObjectNotExistsAsync('Status.' + oid, {\n\t// \t\t\t\t\t\t\t\t\ttype: 'state',\n\t// \t\t\t\t\t\t\t\t\tcommon: {\n\t// \t\t\t\t\t\t\t\t\t\tname: 'Status.' + this.config.OIDs[configOidIndex].name,\n\t// \t\t\t\t\t\t\t\t\t\ttype: 'string',\n\t// \t\t\t\t\t\t\t\t\t\trole: 'value',\n\t// \t\t\t\t\t\t\t\t\t\tread: true,\n\t// \t\t\t\t\t\t\t\t\t\twrite: false,\n\t// \t\t\t\t\t\t\t\t\t},\n\t// \t\t\t\t\t\t\t\t\tnative: {},\n\t// \t\t\t\t\t\t\t\t});\n\t// \t\t\t\t\t\t\t\tthis.setState('Status.' + oid, { val: status, ack: true });\n\t// \t\t\t\t\t\t\t\tthis.log.debug(`Update status object: ${oid} with value: ${status}`);\n\t// \t\t\t\t\t\t\t}\n\t// \t\t\t\t\t\t} else {\n\t// \t\t\t\t\t\t\tthis.log.info(`No status text found for ${oid} (${name})`);\n\t// \t\t\t\t\t\t\tthis.log.info(`Please check isStatus configuration for ${oid}`);\n\t// \t\t\t\t\t\t}\n\t// \t\t\t\t\t}\n\t// \t\t\t\t} catch (error: any) {\n\t// \t\t\t\t\tthis.log.error('Error message: ' + error?.message);\n\t// \t\t\t\t\tthis.log.error(`State update for ${oids} failed`);\n\t// \t\t\t\t}\n\t// \t\t\t});\n\t// \t\t} else {\n\t// \t\t\tthis.log.error(`reading ${oids} failed! Message: ${JSON.stringify(response.statusText)}`);\n\t// \t\t\tthrow new Error(`reading ${oids} failed! Message: ${JSON.stringify(response.statusText)}`);\n\t// \t\t}\n\t// \t} catch (_error: any) {\n\t// \t\tthis.log.error('OID read or parse error: ' + oids);\n\t// \t\tthis.setState('info.connection', false, true);\n\t// \t\tthrow new Error(_error.message ?? 'OID read or parse error');\n\t// \t}\n\t// }\n\n\t/**\n\t * Read OID  from roomterminal, given by index\n\t *\n\t * @param index index of the single OID to read in this.config.OiDs\n\t */\n\t// private async oidReadOld(index: number): Promise<void> {\n\t// \tconst oid = this.config.OIDs[index].oid;\n\n\t// \t// TODO: wrong UID error handling\n\n\t// \tthis.log.debug(`Read OID ${oid}`);\n\t// \tconst body = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t// \t\t<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\"\n\t// \t\txmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\"\n\t// \t\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t// \t\txmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\n\t// \t\txmlns:ns=\"http://ws01.lom.ch/soap/\">\n\t// \t\t <SOAP-ENV:Body>\n\t// \t\t   <ns:getDpRequest>\n\t// \t\t\t<ref>\n\t// \t\t\t <oid>${oid}</oid>\n\t// \t\t\t <prop/>\n\t// \t\t\t</ref>\n\t// \t\t\t<startIndex>0</startIndex>\n\t// \t\t\t<count>-1</count>\n\t// \t\t   </ns:getDpRequest>\n\t// \t\t </SOAP-ENV:Body>\n\t// \t\t</SOAP-ENV:Envelope>`;\n\t// \tthis.log.debug(`Fetch body: ${JSON.stringify(body, null, 2)}`);\n\t// \tconst options = {\n\t// \t\tmethod: 'post',\n\t// \t\tbody: body,\n\t// \t\theaders: {\n\t// \t\t\tConnection: 'Keep-Alive',\n\t// \t\t\tAccept: 'text/xml',\n\t// \t\t\tPragma: 'no-cache',\n\t// \t\t\tSOAPAction: 'http://ws01.lom.ch/soap/getDP',\n\t// \t\t\t'Cache-Control': 'no-cache',\n\t// \t\t\t'Content-Type': 'text/xml; charset=utf-8',\n\t// \t\t\t'Content-length': body.length,\n\t// \t\t},\n\t// \t};\n\t// \ttry {\n\t// \t\tconst response = await this.client.fetch(this.getUrl, options);\n\t// \t\tthis.log.debug(`Fetch response: ${JSON.stringify(response, null, 2)}`);\n\t// \t\tif (response.ok == true) {\n\t// \t\t\t// Reading was succcesfull\n\t// \t\t\tthis.setState('info.connection', true, true);\n\n\t// \t\t\tconst data = await response.text();\n\t// \t\t\tthis.log.debug(`OID Raw Data: ${data}`);\n\t// \t\t\tconst jsonResult = await parseStringPromise(data);\n\t// \t\t\tconst dpCfg: any[] = jsonResult['SOAP-ENV:Envelope']['SOAP-ENV:Body'][0]['ns:getDpResponse'][0].dpCfg;\n\t// \t\t\t// this.log.debug(`DP JSON Length: ${dpCfg.length} / oid array length: ${oidArray.length}`);\n\t// \t\t\tthis.log.debug(`Data: ${JSON.stringify(dpCfg)}`);\n\n\t// \t\t\t// loop through dpCfg[]\n\t// \t\t\tdpCfg.forEach(async (dp) => {\n\t// \t\t\t\tconst states: { [key: string]: string } = {};\n\n\t// \t\t\t\t// this.log.debug(`[Key: ${key}][config OID index: ${configOidIndex}] DP: ${JSON.stringify(dp)}`);\n\n\t// \t\t\t\tconst name: string = dp.name[0];\n\t// \t\t\t\tconst prop: string = dp.prop[0];\n\t// \t\t\t\tconst desc: string = dp.desc[0];\n\t// \t\t\t\tconst value: string = dp.value[0];\n\t// \t\t\t\tconst unit: string = dp.unit[0];\n\t// \t\t\t\tconst step: string = dp.step[0];\n\t// \t\t\t\tconst min: string = dp.minValue[0];\n\t// \t\t\t\tconst max: string = dp.maxValue[0];\n\n\t// \t\t\t\t// this.log.debug(`desc: ${desc}, prop: ${prop}`);\n\n\t// \t\t\t\tif (this.oidEnumsDict![name]) {\n\t// \t\t\t\t\t// this.log.debug(`Enums ${JSON.stringify(this.oidEnumsDict![name])}`);\n\t// \t\t\t\t\tif (desc === 'Enum Var') {\n\t// \t\t\t\t\t\tconst enums = getEnumKeys(prop);\n\t// \t\t\t\t\t\tif (enums) {\n\t// \t\t\t\t\t\t\tenums.forEach(\n\t// \t\t\t\t\t\t\t\t(val) => (states[val] = this.oidEnumsDict![name][Number(val)] ?? 'undefined'),\n\t// \t\t\t\t\t\t\t);\n\t// \t\t\t\t\t\t}\n\t// \t\t\t\t\t} else {\n\t// \t\t\t\t\t\tthis.oidEnumsDict![name].forEach((val, key) => (states[key] = val ?? 'undefined'));\n\t// \t\t\t\t\t}\n\t// \t\t\t\t}\n\t// \t\t\t\t// else this.log.debug('No enums for ' + name);\n\n\t// \t\t\t\t// this.log.debug(`OID states: ${JSON.stringify(states)}`);\n\t// \t\t\t\t// this.log.debug(`configOidIndex: ${configOidIndex}`);\n\t// \t\t\t\t// this.log.debug(`name: ${this.config.OIDs[configOidIndex].name}`);\n\t// \t\t\t\t// this.log.debug(`prop: ${prop}`);\n\t// \t\t\t\t// this.log.debug(`unit: ${unit}`);\n\t// \t\t\t\tthis.log.debug(`Update object: ${oid} - \"${name}\" with value: ${value} `);\n\n\t// \t\t\t\tconst common: ioBroker.StateCommon = {\n\t// \t\t\t\t\tname: this.config.OIDs[index].name.length\n\t// \t\t\t\t\t\t? this.config.OIDs[index].name\n\t// \t\t\t\t\t\t: this.oidNamesDict![name],\n\t// \t\t\t\t\ttype: 'number',\n\t// \t\t\t\t\trole: 'value',\n\t// \t\t\t\t\tread: prop[1] === 'r' ? true : false,\n\t// \t\t\t\t\twrite: prop[2] === 'w' ? true : false,\n\t// \t\t\t\t\tunit: unit.length === 0 ? undefined : unit,\n\t// \t\t\t\t\tmin: prop[2] === 'w' ? (min.length === 0 ? undefined : Number(min)) : undefined,\n\t// \t\t\t\t\tmax: prop[2] === 'w' ? (max.length === 0 ? undefined : Number(max)) : undefined,\n\t// \t\t\t\t\tstep: prop[2] === 'w' ? (step.length === 0 ? undefined : Number(step)) : undefined,\n\t// \t\t\t\t\t//TODO: add states based on XML\n\t// \t\t\t\t\tstates: Object.keys(states).length == 0 ? undefined : states,\n\t// \t\t\t\t\t// \t// states: { '0': 'OFF', '1': 'ON', '-3': 'whatever' },\n\t// \t\t\t\t};\n\t// \t\t\t\t// this.log.debug(`common: ${JSON.stringify(common)}`);\n\n\t// \t\t\t\ttry {\n\t// \t\t\t\t\tif (value.length > 0) {\n\t// \t\t\t\t\t\tawait this.setObjectNotExistsAsync('OID.' + oid, {\n\t// \t\t\t\t\t\t\ttype: 'state',\n\t// \t\t\t\t\t\t\tcommon,\n\t// \t\t\t\t\t\t\tnative: {},\n\t// \t\t\t\t\t\t});\n\n\t// \t\t\t\t\t\tthis.setState('OID.' + oid, { val: Number(value), ack: true });\n\t// \t\t\t\t\t}\n\t// \t\t\t\t\tif (this.config.OIDs[index].isStatus) {\n\t// \t\t\t\t\t\tif (this.oidEnumsDict![name]) {\n\t// \t\t\t\t\t\t\tconst status = this.oidEnumsDict![name][Number(value)];\n\n\t// \t\t\t\t\t\t\tif (status) {\n\t// \t\t\t\t\t\t\t\tawait this.setObjectNotExistsAsync('Status.' + oid, {\n\t// \t\t\t\t\t\t\t\t\ttype: 'state',\n\t// \t\t\t\t\t\t\t\t\tcommon: {\n\t// \t\t\t\t\t\t\t\t\t\tname: 'Status.' + this.config.OIDs[index].name,\n\t// \t\t\t\t\t\t\t\t\t\ttype: 'string',\n\t// \t\t\t\t\t\t\t\t\t\trole: 'value',\n\t// \t\t\t\t\t\t\t\t\t\tread: true,\n\t// \t\t\t\t\t\t\t\t\t\twrite: false,\n\t// \t\t\t\t\t\t\t\t\t},\n\t// \t\t\t\t\t\t\t\t\tnative: {},\n\t// \t\t\t\t\t\t\t\t});\n\t// \t\t\t\t\t\t\t\tthis.setState('Status.' + oid, { val: status, ack: true });\n\t// \t\t\t\t\t\t\t\tthis.log.debug(`Update status object: ${oid} with value: ${status}`);\n\t// \t\t\t\t\t\t\t}\n\t// \t\t\t\t\t\t} else {\n\t// \t\t\t\t\t\t\tthis.log.info(`No status text found for ${oid} (${name})`);\n\t// \t\t\t\t\t\t\tthis.log.info(`Please check isStatus configuration for ${oid}`);\n\t// \t\t\t\t\t\t}\n\t// \t\t\t\t\t}\n\t// \t\t\t\t} catch (error: any) {\n\t// \t\t\t\t\tthis.log.error('Error message: ' + error?.message);\n\t// \t\t\t\t\tthis.log.error(`State update for ${oid} failed`);\n\t// \t\t\t\t}\n\t// \t\t\t});\n\t// \t\t} else {\n\t// \t\t\tthis.log.error(\n\t// \t\t\t\t`reading ${JSON.stringify(oid, null, 2)} failed! Message: ${JSON.stringify(response.statusText)}`,\n\t// \t\t\t);\n\t// \t\t}\n\t// \t} catch (_error) {\n\t// \t\tthis.log.error('OID read or parse error: ' + oid);\n\t// \t\tthis.setState('info.connection', false, true);\n\t// \t}\n\t// }\n\n\t/**\n\t * Write OID to roomterminal, given by index\n\t *\n\t * @param index index of the OID etnry to tread in this.config.OiDs\n\t */\n\tprivate async oidWrite(index: number, value: any): Promise<void> {\n\t\t// this.log.debug(JSON.stringify(oids, null, 2));\n\t\t// this.log.debug(JSON.stringify(status, null, 2));\n\t\tconst oid = this.config.OIDs[index].oid;\n\t\tconst ind = oid.slice(oid.lastIndexOf('/') - oid.length + 1);\n\t\t// const ind = oid.charAt(oid.length - 1);\n\n\t\t// TODO: wrong UID error handling\n\t\tconst body = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t\t<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" \n\t\txmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\" \n\t\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n\t\txmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" \n\t\txmlns:ns=\"http://ws01.lom.ch/soap/\">\n\t\t<SOAP-ENV:Body>\n\t\t  <ns:writeDpRequest>\n\t\t   <ref>\n\t\t\t<oid>${oid}</oid>\n\t\t\t<prop/>\n\t\t   </ref>\n\t\t   <dp>\n\t\t\t<index>${ind}</index>\n\t\t\t<name/>\n\t\t\t<prop/>\n\t\t\t<desc/>\n\t\t\t<value>${value}</value>\n\t\t\t<unit/>\n\t\t\t<timestamp>0</timestamp>\n\t\t   </dp>\n\t\t  </ns:writeDpRequest>   \n\t\t</SOAP-ENV:Body>\n\t   </SOAP-ENV:Envelope>`;\n\t\tthis.log.debug(`write body ${oid}: ${body}`);\n\n\t\tconst options = {\n\t\t\tmethod: 'post',\n\t\t\tbody: body,\n\t\t\theaders: {\n\t\t\t\tConnection: 'Keep-Alive',\n\t\t\t\tAccept: '*/*',\n\t\t\t\tPragma: 'no-cache',\n\t\t\t\tSOAPAction: 'http://ws01.lom.ch/soap/writeDP',\n\t\t\t\t'Cache-Control': 'no-cache',\n\t\t\t\t'Content-Type': 'text/xml; charset=utf-8',\n\t\t\t\t'Content-length': body.length,\n\t\t\t},\n\t\t};\n\t\ttry {\n\t\t\tthis.log.debug(`Write OID ${oid} (XML-index ${ind}) with value: ${value}`);\n\t\t\tconst response = await this.client.fetch(this.getUrl, options);\n\t\t\tif (response.ok != true)\n\t\t\t\tthis.log.debug(`writing ${oid} failed\" Message: ${JSON.stringify(response.statusText)}`);\n\t\t} catch (error) {\n\t\t\tthis.log.error(`OID (${oid}) write error: ${JSON.stringify(error)}`);\n\t\t\tthis.setState('info.connection', false, true);\n\t\t}\n\t}\n\n\t/**\n\t * Ochnser API for getting the oidNames Dictionary,\n\t * \t\teither from file\n\t * \t\tor\n\t * \t\tfrom device (then stored to file)\n\t *\n\t * @returns oiNameDictionary\n\t */\n\tprivate async oidGetNames(): Promise<{ [id: string]: string }> {\n\t\tlet oidNamesDict: { [id: string]: string } = {};\n\t\tconst fileName = 'oidNames.json';\n\t\ttry {\n\t\t\tconst oidNamesExists = await this.fileExistsAsync(this.namespace, fileName);\n\t\t\tif (oidNamesExists) {\n\t\t\t\tthis.log.debug('oidNames.json exists - skip reading from Device');\n\t\t\t\tconst res = await this.readFileAsync(this.namespace, fileName);\n\t\t\t\t// @ts-expect-error Type of res in invalid.\n\t\t\t\toidNamesDict = JSON.parse(res.file);\n\t\t\t\t// this.log.info(`res: ${JSON.stringify(res.file)}`);\n\t\t\t} else {\n\t\t\t\tconst response = await this.client.fetch(\n\t\t\t\t\t'http://192.168.1.108/res/xml/VarIdentTexte_de.xml',\n\t\t\t\t\tgetOptions,\n\t\t\t\t);\n\t\t\t\tconst data = await response.text();\n\t\t\t\tconst result = await parseStringPromise(data);\n\n\t\t\t\tfor (const gnIndex in result['VarIdentTexte']['gn']) {\n\t\t\t\t\tfor (const mnIndex in result['VarIdentTexte']['gn'][gnIndex]['mn']) {\n\t\t\t\t\t\tlet gn = result['VarIdentTexte']['gn'][gnIndex]['$']['id'];\n\t\t\t\t\t\tlet mn = result['VarIdentTexte']['gn'][gnIndex]['mn'][mnIndex]['$']['id'];\n\t\t\t\t\t\tif (gn.length == 1) gn = '0' + gn;\n\t\t\t\t\t\tif (mn.length == 1) mn = '0' + mn;\n\t\t\t\t\t\tconst key = `${gn}:${mn}`;\n\t\t\t\t\t\toidNamesDict[key] = result['VarIdentTexte']['gn'][gnIndex]['mn'][mnIndex]['_'];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tawait this.writeFileAsync(this.namespace, fileName, JSON.stringify(oidNamesDict));\n\t\t\t\tthis.log.debug(`${fileName} written to 'Files'`);\n\t\t\t\t// return oidNamesDict;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.log.error(`oidGetNames error: ${JSON.stringify(error)}`);\n\t\t}\n\t\treturn oidNamesDict;\n\t}\n\n\t/**\n\t * Ochnser API for getting the oidEnum Dictionary,\n\t * \t\teither from file\n\t * \t\tor\n\t * \t\tfrom device (then stored to file)\n\t *\n\t * @returns oidEnumDictionary\n\t */\n\tprivate async oidGetEnums(): Promise<{ [id: string]: string[] }> {\n\t\tlet oidEnumsDict: { [id: string]: string[] } = {};\n\t\tconst fileName = 'oidEnums.json';\n\t\ttry {\n\t\t\tconst oidEnumsExists = await this.fileExistsAsync(this.namespace, fileName);\n\t\t\tif (oidEnumsExists) {\n\t\t\t\tthis.log.debug('oidEnums.json exists - skip reading from Device');\n\t\t\t\tconst res = await this.readFileAsync(this.namespace, fileName);\n\t\t\t\t// @ts-expect-error Type of res in invalid.\n\t\t\t\toidEnumsDict = JSON.parse(res.file);\n\t\t\t\t// this.log.info(`res: ${JSON.stringify(res.file)}`);\n\t\t\t} else {\n\t\t\t\tconst response = await this.client.fetch(\n\t\t\t\t\t'http://192.168.1.108/res/xml/AufzaehlTexte_de.xml',\n\t\t\t\t\tgetOptions,\n\t\t\t\t);\n\t\t\t\tconst data = await response.text();\n\t\t\t\tconst result = await parseStringPromise(data);\n\t\t\t\t// console.log(JSON.stringify(result['AufzaehlTexte']['gn'], null, 2));\n\t\t\t\tfor (const gnIndex in result['AufzaehlTexte']['gn']) {\n\t\t\t\t\tfor (const mnIndex in result['AufzaehlTexte']['gn'][gnIndex]['mn']) {\n\t\t\t\t\t\tlet gn = result['AufzaehlTexte']['gn'][gnIndex]['$']['id'];\n\t\t\t\t\t\tlet mn = result['AufzaehlTexte']['gn'][gnIndex]['mn'][mnIndex]['$']['id'];\n\t\t\t\t\t\tgn = gn.length == 1 ? '0' + gn : gn;\n\t\t\t\t\t\tmn = mn.length == 1 ? '0' + mn : mn;\n\t\t\t\t\t\tconst key = `${gn}:${mn}`;\n\t\t\t\t\t\tconst enumArray: string[] = [];\n\t\t\t\t\t\tfor (const enumIndex in result['AufzaehlTexte']['gn'][gnIndex]['mn'][mnIndex]['enum']) {\n\t\t\t\t\t\t\tconst index = parseInt(\n\t\t\t\t\t\t\t\tresult['AufzaehlTexte']['gn'][gnIndex]['mn'][mnIndex]['enum'][enumIndex]['$']['id'],\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tenumArray[index] =\n\t\t\t\t\t\t\t\tresult['AufzaehlTexte']['gn'][gnIndex]['mn'][mnIndex]['enum'][enumIndex]['_'];\n\t\t\t\t\t\t}\n\t\t\t\t\t\toidEnumsDict[key] = enumArray;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tawait this.writeFileAsync(this.namespace, fileName, JSON.stringify(oidEnumsDict));\n\t\t\t\tthis.log.debug(`${fileName} written to 'Files'`);\n\t\t\t\t// return oidEnumsDict;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.log('error:', { error });\n\t\t}\n\t\treturn oidEnumsDict;\n\t}\n\t/**\n\t * Ochnser API for getting the DeviceInfo\n\t * @returns\n\t */\n\tprivate async checkForConnection(): Promise<boolean> {\n\t\t// this.log.debug('DeviceInfo URL: ' + this.deviceInfoUrl);\n\t\ttry {\n\t\t\tconst response = await this.client.fetch(this.deviceInfoUrl, getOptions);\n\t\t\tconst data = await response.json();\n\t\t\tthis.log.info('DeviceInfo: ' + JSON.stringify(data));\n\t\t\tthis.setStateAsync('deviceInfo.name', { val: data.device, ack: true });\n\t\t\tthis.setStateAsync('deviceInfo.version', { val: data.version, ack: true });\n\t\t} catch (error) {\n\t\t\tthis.log.error('Invalid username, password or server IP-address in adapter configuration');\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}\n\nif (require.main !== module) {\n\t// Export the constructor in compact mode\n\tmodule.exports = (options: Partial<utils.AdapterOptions> | undefined) => new OchsnerRoomterminal(options);\n} else {\n\t// otherwise start the instance directly\n\t(() => new OchsnerRoomterminal())();\n}\n"],
  "mappings": "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",
  "names": ["packageJson", "DigestFetch", "_a", "key"]
}
