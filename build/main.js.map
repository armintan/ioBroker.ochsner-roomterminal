{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/*\n * Created with @iobroker/create-adapter v2.6.2\n */\n\n// The adapter-core module gives you access to the core ioBroker functions\n// you need to create an adapter\nimport * as utils from '@iobroker/adapter-core';\nimport { parseStringPromise } from 'xml2js';\nimport packageJson from '../package.json';\nimport { getEnumKeys } from './lib/util.js';\n\n// Load your modules here, e.g.:\nimport DigestFetch from 'digest-fetch';\n\n// import * as fs from \"fs\";\nconst adapterName = packageJson.name.split('.').pop();\nconst getOptions = {\n    method: 'get',\n    headers: {\n        Connection: 'Keep-Alive',\n        Accept: 'text/xml',\n        Pragma: 'no-cache',\n        'Cache-Control': 'no-cache',\n        'Content-Type': 'text/xml; charset=utf-8',\n    },\n};\n\n// /home/parallels/ioBroker.ochsner-roomterminal/node_modules/@types/iobroker/index.d.ts\nclass OchsnerRoomterminal extends utils.Adapter {\n    private deviceInfoUrl = '';\n    private getUrl = '';\n    private client: any | undefined = undefined;\n    private oidNamesDict: { [id: string]: string } | undefined = undefined;\n    private oidEnumsDict: { [id: string]: string[] } | undefined = undefined;\n    private oidUpdate: { [id: string]: string } = {};\n    private oidGroups: Record<string, number[]> = {};\n    private groupOidString: Record<string, string> = {};\n\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: adapterName!,\n        });\n        // this.log.info(`Adapter Name: ${this.name}`);\n        // this.log.info(`Adapter Instance: ${this.instance}`);\n        // this.log.info(`Adapter Namespace: ${this.namespace}`);\n        this.on('ready', this.onReady.bind(this));\n        this.on('stateChange', this.onStateChange.bind(this));\n        // this.on('objectChange', this.onObjectChange.bind(this));\n        this.on('message', this.onMessage.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n    }\n\n    /**\n     * Is called when databases are connected and adapter received configuration.\n     */\n    private async onReady(): Promise<void> {\n        // Initialize your adapter here\n        this.subscribeStates('OID.*');\n        this.log.info(`Adapter Name: ${this.name} is ready !!!!!!`);\n        this.main();\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     * @param callback\n     */\n    private onUnload(callback: () => void): void {\n        try {\n            // Here you must clear all timeouts or intervals that may still be active\n            // clearTimeout(timeout1);\n            // clearTimeout(timeout2);\n            // ...\n            // clearInterval(interval1);\n\n            callback();\n        } catch (e) {\n            callback();\n        }\n    }\n\n    // If you need to react to object changes, uncomment the following block and the corresponding line in the constructor.\n    // You also need to subscribe to the objects with `this.subscribeObjects`, similar to `this.subscribeStates`.\n    // /**\n    //  * Is called if a subscribed object changes\n    //  */\n    // private onObjectChange(id: string, obj: ioBroker.Object | null | undefined): void {\n    // \tif (obj) {\n    // \t\t// The object was changed\n    // \t\tthis.log.info(`object ${id} changed: ${JSON.stringify(obj)}`);\n    // \t} else { 17058\n    // \t\t// The object was deleted\n    // \t\tthis.log.info(`object ${id} deleted`);\n    // \t}\n    // }\n\n    /**\n     * Is called if a subscribed state changes\n     * @param id\n     * @param state\n     * @param id\n     * @param state\n     */\n    private async onStateChange(id: string, state: ioBroker.State | null | undefined): Promise<void> {\n        const oids = this.config.OIDs;\n        if (state) {\n            // The state was changed\n            if (!state.ack) {\n                // only write to device value if state is not acknowledged\n                this.log.debug(`state ${id} changed: ${state.val} (ack = ${state.ack})`);\n                const index = oids.findIndex(elem => id.endsWith(elem.oid));\n                if (index == -1) {\n                    this.log.error(`state ${id} not found in OID list`);\n                    return;\n                }\n                // this.log.debug(`adapter name: ${this.name}, namespace: ${this.namespace}`);\n                this.log.debug(`From: system.adapter.${this.name}`);\n                // we are only interested in state changes, which are not from reading our OIDs\n                if (!state.from.startsWith(`system.adapter.${this.name}`)) {\n                    await this.oidWrite(index, state.val);\n                    await this.delay(1500);\n                    await this.oidRead(this.config.OIDs[index].oid, [index]);\n                }\n            }\n        } else {\n            // The state was deleted\n            this.log.info(`state ${id} deleted`);\n        }\n    }\n\n    // If you need to accept messages in your adapter, uncomment the following block and the corresponding line in the constructor.\n    // /**\n    //  * Some message was sent to this instance over message box. Used by email, pushover, text2speech, ...\n    //  * Using this method requires \"common.messagebox\" property to be set to true in io-package.json\n    //  */\n    private async onMessage(obj: ioBroker.Message): Promise<void> {\n        this.log.debug('message received' + JSON.stringify(obj, null, 2));\n        let resultMsg: any = { error: 'internal error' };\n        // let resultMsg = { error: false, result: 'success' };\n        if (typeof obj === 'object' && obj.message) {\n            if (obj.command === 'readGroup') {\n                // read group with string 'obj.command'\n                const groupIndex = Object.keys(this.oidGroups).indexOf(String(obj.message));\n                this.log.debug(`read group ${obj.message} (groupIndex: ${groupIndex})`);\n\n                if (groupIndex !== -1) {\n                    try {\n                        const group = String(obj.message);\n                        // await this.oidReadGroupOld(String(obj.message));\n                        await this.oidRead(this.groupOidString[group], this.oidGroups[group]);\n                        resultMsg = 'success';\n                    } catch (error: any) {\n                        resultMsg = { error: error.message ?? 'unknown error' };\n                    }\n                } else {\n                    this.log.info(`group \"${obj.message}\" does not exist`);\n                    resultMsg = { error: `group ${obj.message} does not exist` };\n                }\n            } else {\n                resultMsg = { error: 'message command not supported' };\n            }\n        }\n        // Send response in callback if required\n        // if (obj.callback) this.sendTo(obj.from, obj.command, 'Message received', obj.callback);\n        if (obj.callback) {\n            this.sendTo(obj.from, obj.command, resultMsg, obj.callback);\n        }\n    }\n\n    /**\n     * -----------------\n     * Private functions\n     * -----------------\n     */\n\n    /**\n     *  Inititialize the adapter\n     * ----------------------------\n     */\n    private async main(): Promise<void> {\n        // Reset the connection indicator during startup\n        this.setState('info.connection', false, true);\n\n        // Initialize private instance variables\n        this.deviceInfoUrl = `http://${this.config.serverIP}/api/1.0/info/deviceinfo`;\n        this.getUrl = `http://${this.config.serverIP}/ws`;\n        this.client = new DigestFetch(this.config.username, this.config.password);\n\n        // Attention !!!\n        // this.log.info(`Config: ${JSON.stringify(this.config, null, 2)}`);\n\n        // The adapters config (in the instance object everything under the attribute \"native\") is accessible via\n        // this.config:\n        if (!this.config.serverIP) {\n            this.log.error('Server IP address configuration must not be emtpy');\n            return;\n        }\n\n        this.log.info('Config username: ' + this.config.username);\n        // this.log.info('Config password: ' + this.config.password);\n        this.log.info('Config serverIP: ' + this.config.serverIP);\n        this.log.info('Config pollInterval: ' + this.config.pollInterval);\n\n        // check if connection to server is available with given credentials\n        const connected = await this.checkForConnection();\n        if (!connected) {\n            return;\n        }\n        this.setState('info.connection', true, true);\n\n        /**\n         * Prepare Group Handling\n         * ----------------------\n         * this.oidGroups = {\"group01\": [OIDsIndex01, OIDsIndex02, ....],\"group02\": [OIDsIndex01, OIDsIndex02, ....], .... }\n         * this.groupOIDString = {\"group01\": \"oid1;oid3\", \"group02\": \"oid2;oid4\"}\n         */\n        if (this.config.OIDs?.length) {\n            this.config.OIDs.forEach((value, key) => {\n                const group = this.config.OIDs[key].group;\n                const enabled = this.config.OIDs[key].enabled;\n                const oid = this.config.OIDs[key].oid;\n                this.log.debug(`Key: ${key} Object: ${JSON.stringify(this.config.OIDs[key])}`);\n                if (enabled) {\n                    if (this.oidGroups[group] == undefined) this.oidGroups[group] = [key];\n                    else this.oidGroups[group].push(key);\n                    if (this.groupOidString[group] == undefined) this.groupOidString[group] = oid;\n                    else this.groupOidString[group] = this.groupOidString[group] + ';' + oid;\n                }\n            });\n            this.log.debug(`Groups: ${JSON.stringify(this.oidGroups)}`);\n            this.log.debug(`Group OIDs: ${JSON.stringify(this.groupOidString)}`);\n\n            // load the oidNames and oiEnums dictionary\n            // TODO: read both dictionary also, when device version changed\n            this.oidNamesDict = await this.oidGetNames();\n            this.oidEnumsDict = await this.oidGetEnums();\n        }\n\n        // Start polling the OID's when there is at least one OID group <= 10\n        if (Object.keys(this.oidGroups).findIndex(groupName => +groupName < 10) == -1)\n            this.log.info('No OIDs to poll in instance configuration');\n        else this.poll();\n    }\n\n    /**\n     * Main polling routine - fetching next Group in list\n     *\n     * @param groupIndex number\n     * @description Started once during startup, restarts itself when finished\n     * \t\t\t\t(only called when there is at least one group 0-9)\n     */\n    private async poll(groupIndex = 0): Promise<void> {\n        const keys = Object.keys(this.oidGroups);\n        // this.log.debug(`poll with groupIndex: ${groupIndex}; keys length: ${keys.length}`);\n\n        // TODO: avoid delay when OID is disabled\n        try {\n            // read the next OID group from roomterminal\n            if (groupIndex >= keys.length) {\n                // we read the last group\n                await this.updateNativeOIDs();\n                this.poll(0); // start from the beginning, without delay\n            } else if (+keys[groupIndex] > 9) {\n                // groupNames from 10 onwards are reserved for messages\n                this.log.debug(\n                    `skip group ${keys[groupIndex]}, groups with numbers > 9 are reserved for readGroup messages, only!!`,\n                );\n                this.poll(++groupIndex);\n            } else {\n                const groupKey = keys[groupIndex];\n                this.log.debug(`Read Group ${groupKey}`);\n                // await this.oidReadGroupOld(groupKey);\n                await this.oidRead(this.groupOidString[groupKey], this.oidGroups[groupKey]);\n                await this.delay(this.config.pollInterval * 1000);\n                this.poll(++groupIndex);\n            }\n        } catch (error) {\n            this.log.error(`Error: ${JSON.stringify(error)}`);\n            await this.delay(this.config.pollInterval * 1000);\n            this.poll(0);\n        }\n    }\n\n    /**\n     * Check for empty OID names in config, add default names\n     * and update common.native.OIDs in instance object (which restarts the adapter)\n     */\n    private async updateNativeOIDs(): Promise<void> {\n        const keys = Object.keys(this.oidUpdate);\n        if (!keys.length) return; // there is nothing to update\n\n        this.log.debug(`UpdateNativeOIDs: ${JSON.stringify(keys)}`);\n        try {\n            const instanceObj = await this.getForeignObjectAsync(`system.adapter.${this.namespace}`);\n            if (instanceObj) {\n                // this.log.debug(`Old native objects: ${JSON.stringify(instanceObj.native, null, 2)}`);\n                keys.forEach(key => {\n                    const index = instanceObj.native.OIDs.findIndex((oid: ioBroker.OID) => key === oid.oid);\n                    if (index !== -1) instanceObj.native.OIDs[index].name = this.oidUpdate[key] ?? key;\n                });\n                // this.log.debug(`New native objects: ${JSON.stringify(instanceObj.native, null, 2)}`);\n                await this.setForeignObjectAsync(`system.adapter.${this.namespace}`, instanceObj);\n                this.oidUpdate = {};\n                // this.log.debug(`Instance object id: ${JSON.stringify(res, null, 2)}`);\n            }\n        } catch (error) {\n            this.log.debug(`getObject error: ${JSON.stringify(error, null, 2)}`);\n        }\n    }\n\n    /**\n     * Read OID group from roomterminal, given by group oids and group indices\n     *\n     * @param oids OID string to read e.g. \"/1/2/3/5/8;/1/2/3/5/;/1/2/3/5/10\"\n     * @param indices OID config indices [5,7,9] (must correspond to oids)\n     * @param oidIndices number\n     */\n    private async oidRead(oids: string, oidIndices: number[]): Promise<void> {\n        this.log.debug(`Read OIDs ${oids} (Config indices: [ ${JSON.stringify(oidIndices)} ])`);\n\n        // TODO: wrong OID error handling\n\n        const body = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t\t<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" \n\t\txmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\" \n\t\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n\t\txmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" \n\t\txmlns:ns=\"http://ws01.lom.ch/soap/\">\n\t\t <SOAP-ENV:Body>\n\t\t   <ns:getDpRequest>\n\t\t\t<ref>\n\t\t\t <oid>${oids}</oid>\n\t\t\t <prop/>\n\t\t\t</ref>\n\t\t\t<startIndex>0</startIndex>\n\t\t\t<count>-1</count>\n\t\t   </ns:getDpRequest>\n\t\t </SOAP-ENV:Body>\n\t\t</SOAP-ENV:Envelope>`;\n\n        const options = {\n            method: 'post',\n            body: body,\n            headers: {\n                Connection: 'Keep-Alive',\n                Accept: 'text/xml',\n                Pragma: 'no-cache',\n                SOAPAction: 'http://ws01.lom.ch/soap/getDP',\n                'Cache-Control': 'no-cache',\n                'Content-Type': 'text/xml; charset=utf-8',\n                'Content-length': body.length,\n            },\n        };\n        try {\n            const response = await this.client.fetch(this.getUrl, options);\n            if (response.ok == true) {\n                // Reading was succcesfull\n                this.setState('info.connection', true, true);\n\n                const data = await response.text();\n                this.log.debug(`OID Raw Data: ${data}`);\n                const jsonResult = await parseStringPromise(data);\n                const dpCfg: any[] = jsonResult['SOAP-ENV:Envelope']['SOAP-ENV:Body'][0]['ns:getDpResponse'][0].dpCfg;\n                // this.log.debug(`DP JSON Length: ${dpCfg.length} / oid array length: ${oidArray.length}`);\n                // this.log.debug(`Data: ${JSON.stringify(dpCfg)}`);\n\n                // loop through dpCfg[]\n                dpCfg.forEach(async (dp, key) => {\n                    const configOidIndex = oidIndices[key];\n                    const oid = this.config.OIDs[configOidIndex].oid;\n                    const states: { [key: string]: string } = {};\n\n                    // this.log.debug(`[Key: ${key}][config OID index: ${configOidIndex}] DP: ${JSON.stringify(dp)}`);\n\n                    const name: string = dp.name[0];\n                    const prop: string = dp.prop[0];\n                    const desc: string = dp.desc[0];\n                    const value: string = dp.value[0];\n                    const unit: string = dp.unit[0];\n                    const step: string = dp.step[0];\n                    const min: string = dp.minValue[0];\n                    const max: string = dp.maxValue[0];\n\n                    // this.log.debug(`desc: ${desc}, prop: ${prop}`);\n\n                    if (this.oidEnumsDict![name]) {\n                        // this.log.debug(`Enums ${JSON.stringify(this.oidEnumsDict![name])}`);\n                        if (desc === 'Enum Var') {\n                            const enums = getEnumKeys(prop);\n                            if (enums) {\n                                enums.forEach(\n                                    val => (states[val] = this.oidEnumsDict![name][Number(val)] ?? 'undefined'),\n                                );\n                            }\n                        } else {\n                            this.oidEnumsDict![name].forEach((val, key) => (states[key] = val ?? 'undefined'));\n                        }\n                    }\n                    // else this.log.debug('No enums for ' + name);\n\n                    // this.log.debug(`OID states: ${JSON.stringify(states)}`);\n                    // this.log.debug(`configOidIndex: ${configOidIndex}`);\n                    // this.log.debug(`name: ${this.config.OIDs[configOidIndex].name}`);\n                    // this.log.debug(`prop: ${prop}`);\n                    // this.log.debug(`unit: ${unit}`);\n                    this.log.debug(`Update object: ${oid} - \"${name}\" with value: ${value} `);\n\n                    const common: ioBroker.StateCommon = {\n                        name: this.config.OIDs[configOidIndex].name.length\n                            ? this.config.OIDs[configOidIndex].name\n                            : this.oidNamesDict![name],\n                        type: 'number',\n                        role: 'value',\n                        read: prop[1] === 'r' ? true : false,\n                        write: prop[2] === 'w' ? true : false,\n                        unit: unit.length === 0 ? undefined : unit,\n                        min: prop[2] === 'w' ? (min.length === 0 ? undefined : Number(min)) : undefined,\n                        max: prop[2] === 'w' ? (max.length === 0 ? undefined : Number(max)) : undefined,\n                        step: prop[2] === 'w' ? (step.length === 0 ? undefined : Number(step)) : undefined,\n                        //TODO: add states based on XML\n                        states: Object.keys(states).length == 0 ? undefined : states,\n                        // \t// states: { '0': 'OFF', '1': 'ON', '-3': 'whatever' },\n                    };\n                    // this.log.debug(`common: ${JSON.stringify(common)}`);\n\n                    if (this.config.OIDs[configOidIndex].name.length === 0)\n                        this.oidUpdate[oid] = this.oidNamesDict![name] ?? name;\n                    try {\n                        if (value.length > 0) {\n                            await this.setObjectNotExistsAsync('OID.' + oid, {\n                                type: 'state',\n                                common,\n                                native: {},\n                            });\n\n                            this.setState('OID.' + oid, { val: Number(value), ack: true });\n                        }\n                        if (this.config.OIDs[configOidIndex].isStatus) {\n                            // this.log.debug(`oidRead: for ${name}`);\n                            // this.log.debug(`Enums ${JSON.stringify(this.oidEnumsDict![name])}`);\n                            if (this.oidEnumsDict![name]) {\n                                const status = this.oidEnumsDict![name][Number(value)];\n                                if (status) {\n                                    await this.setObjectNotExistsAsync('Status.' + oid, {\n                                        type: 'state',\n                                        common: {\n                                            name: 'Status.' + this.config.OIDs[configOidIndex].name,\n                                            type: 'string',\n                                            role: 'value',\n                                            read: true,\n                                            write: false,\n                                        },\n                                        native: {},\n                                    });\n                                    this.setState('Status.' + oid, { val: status, ack: true });\n                                    this.log.debug(`Update status object: ${oid} with value: ${status}`);\n                                }\n                            } else {\n                                this.log.info(`No status text found for ${oid} (${name})`);\n                                this.log.info(`Please check isStatus configuration for ${oid}`);\n                            }\n                        }\n                    } catch (error: any) {\n                        this.log.error('Error message: ' + error?.message);\n                        this.log.error(`State update for ${oids} failed`);\n                    }\n                });\n            } else {\n                this.log.error(`reading ${oids} failed! Message: ${JSON.stringify(response.statusText)}`);\n                throw new Error(`reading ${oids} failed! Message: ${JSON.stringify(response.statusText)}`);\n            }\n        } catch (_error: any) {\n            this.log.error('OID read or parse error: ' + oids);\n            this.setState('info.connection', false, true);\n            throw new Error(_error.message ?? 'OID read or parse error');\n        }\n    }\n\n    /**\n     * Write OID to roomterminal, given by index\n     *\n     * @param index index of the OID etnry to read in this.config.OiDs\n     */\n    private async oidWrite(index: number, value: any): Promise<void> {\n        // this.log.debug(JSON.stringify(oids, null, 2));\n        // this.log.debug(JSON.stringify(status, null, 2));\n        const oid = this.config.OIDs[index].oid;\n        const ind = oid.slice(oid.lastIndexOf('/') - oid.length + 1);\n        // const ind = oid.charAt(oid.length - 1);\n\n        // TODO: wrong OID error handling\n        const body = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t\t<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" \n\t\txmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\" \n\t\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n\t\txmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" \n\t\txmlns:ns=\"http://ws01.lom.ch/soap/\">\n\t\t<SOAP-ENV:Body>\n\t\t  <ns:writeDpRequest>\n\t\t   <ref>\n\t\t\t<oid>${oid}</oid>\n\t\t\t<prop/>\n\t\t   </ref>\n\t\t   <dp>\n\t\t\t<index>${ind}</index>\n\t\t\t<name/>\n\t\t\t<prop/>\n\t\t\t<desc/>\n\t\t\t<value>${value}</value>\n\t\t\t<unit/>\n\t\t\t<timestamp>0</timestamp>\n\t\t   </dp>\n\t\t  </ns:writeDpRequest>   \n\t\t</SOAP-ENV:Body>\n\t   </SOAP-ENV:Envelope>`;\n        this.log.debug(`write body ${oid}: ${body}`);\n\n        const options = {\n            method: 'post',\n            body: body,\n            headers: {\n                Connection: 'Keep-Alive',\n                Accept: '*/*',\n                Pragma: 'no-cache',\n                SOAPAction: 'http://ws01.lom.ch/soap/writeDP',\n                'Cache-Control': 'no-cache',\n                'Content-Type': 'text/xml; charset=utf-8',\n                'Content-length': body.length,\n            },\n        };\n        try {\n            this.log.debug(`Write OID ${oid} (XML-index ${ind}) with value: ${value}`);\n            const response = await this.client.fetch(this.getUrl, options);\n            if (response.ok != true)\n                this.log.debug(`writing ${oid} failed\" Message: ${JSON.stringify(response.statusText)}`);\n        } catch (error) {\n            this.log.error(`OID (${oid}) write error: ${JSON.stringify(error)}`);\n            this.setState('info.connection', false, true);\n        }\n    }\n\n    /**\n     * Ochnser API for getting the oidNames Dictionary,\n     * \t\teither from file\n     * \t\tor\n     * \t\tfrom device (then stored to file)\n     *\n     * @returns oiNameDictionary\n     */\n    private async oidGetNames(): Promise<{ [id: string]: string }> {\n        let oidNamesDict: { [id: string]: string } = {};\n        const fileName = 'oidNames.json';\n        try {\n            const oidNamesExists = await this.fileExistsAsync(this.namespace, fileName);\n            if (oidNamesExists) {\n                this.log.debug('oidNames.json file exists - skip reading from device');\n                const res = await this.readFileAsync(this.namespace, fileName);\n                // @ts-expect-error Type of res in invalid.\n                oidNamesDict = JSON.parse(res.file);\n                // this.log.info(`res: ${JSON.stringify(res.file)}`);\n            } else {\n                // this.log.debug(`Read oidNames.json file from device`);\n                const response = await this.client.fetch(\n                    `http://${this.config.serverIP}/res/xml/VarIdentTexte_de.xml`,\n                    getOptions,\n                );\n                const data = await response.text();\n                const result = await parseStringPromise(data);\n\n                for (const gnIndex in result['VarIdentTexte']['gn']) {\n                    for (const mnIndex in result['VarIdentTexte']['gn'][gnIndex]['mn']) {\n                        let gn = result['VarIdentTexte']['gn'][gnIndex]['$']['id'];\n                        let mn = result['VarIdentTexte']['gn'][gnIndex]['mn'][mnIndex]['$']['id'];\n                        if (gn.length == 1) gn = '0' + gn;\n                        if (mn.length == 1) mn = '0' + mn;\n                        const key = `${gn}:${mn}`;\n                        oidNamesDict[key] = result['VarIdentTexte']['gn'][gnIndex]['mn'][mnIndex]['_'];\n                    }\n                }\n                await this.writeFileAsync(this.namespace, fileName, JSON.stringify(oidNamesDict));\n                this.log.debug(`${fileName} written to 'Files'`);\n                // return oidNamesDict;\n            }\n        } catch (error) {\n            this.log.error(`oidGetNames error: ${JSON.stringify(error)}`);\n        }\n        return oidNamesDict;\n    }\n\n    /**\n     * Ochnser API for getting the oidEnum Dictionary,\n     * \t\teither from file\n     * \t\tor\n     * \t\tfrom device (then stored to file)\n     *\n     * @returns oidEnumDictionary\n     */\n    private async oidGetEnums(): Promise<{ [id: string]: string[] }> {\n        let oidEnumsDict: { [id: string]: string[] } = {};\n        const fileName = 'oidEnums.json';\n        try {\n            const oidEnumsExists = await this.fileExistsAsync(this.namespace, fileName);\n            if (oidEnumsExists) {\n                this.log.debug('oidEnums.json file exists - skip reading from device');\n                const res = await this.readFileAsync(this.namespace, fileName);\n                // @ts-expect-error Type of res in invalid.\n                oidEnumsDict = JSON.parse(res.file);\n                // this.log.info(`res: ${JSON.stringify(res.file)}`);\n            } else {\n                //this.log.debug(`Read oidEnums.json file from device`);\n                const response = await this.client.fetch(\n                    `http://${this.config.serverIP}/res/xml/AufzaehlTexte_de.xml`,\n                    getOptions,\n                );\n                const data = await response.text();\n                const result = await parseStringPromise(data);\n                // console.log(JSON.stringify(result['AufzaehlTexte']['gn'], null, 2));\n                for (const gnIndex in result['AufzaehlTexte']['gn']) {\n                    for (const mnIndex in result['AufzaehlTexte']['gn'][gnIndex]['mn']) {\n                        let gn = result['AufzaehlTexte']['gn'][gnIndex]['$']['id'];\n                        let mn = result['AufzaehlTexte']['gn'][gnIndex]['mn'][mnIndex]['$']['id'];\n                        gn = gn.length == 1 ? '0' + gn : gn;\n                        mn = mn.length == 1 ? '0' + mn : mn;\n                        const key = `${gn}:${mn}`;\n                        const enumArray: string[] = [];\n                        for (const enumIndex in result['AufzaehlTexte']['gn'][gnIndex]['mn'][mnIndex]['enum']) {\n                            const index = parseInt(\n                                result['AufzaehlTexte']['gn'][gnIndex]['mn'][mnIndex]['enum'][enumIndex]['$']['id'],\n                            );\n                            enumArray[index] =\n                                result['AufzaehlTexte']['gn'][gnIndex]['mn'][mnIndex]['enum'][enumIndex]['_'];\n                        }\n                        oidEnumsDict[key] = enumArray;\n                    }\n                }\n                await this.writeFileAsync(this.namespace, fileName, JSON.stringify(oidEnumsDict));\n                this.log.debug(`${fileName} written to 'Files'`);\n                // return oidEnumsDict;\n            }\n        } catch (error) {\n            console.log('error:', { error });\n        }\n        return oidEnumsDict;\n    }\n    /**\n     * Ochnser API for getting the DeviceInfo\n     * @returns\n     */\n    private async checkForConnection(): Promise<boolean> {\n        // this.log.debug('DeviceInfo URL: ' + this.deviceInfoUrl);\n        try {\n            const response = await this.client.fetch(this.deviceInfoUrl, getOptions);\n            // this.log.error(JSON.stringify(response, null, 2));\n            const data = await response.json();\n            this.setStateAsync('deviceInfo.name', { val: data.device, ack: true });\n            this.setStateAsync('deviceInfo.version', { val: data.version, ack: true });\n        } catch (error) {\n            this.log.error('Invalid username, password or server IP-address in adapter configuration');\n            return false;\n        }\n        return true;\n    }\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new OchsnerRoomterminal(options);\n} else {\n    // otherwise start the instance directly\n    (() => new OchsnerRoomterminal())();\n}\n"],
  "mappings": "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",
  "names": ["packageJson", "DigestFetch", "_a", "key"]
}
